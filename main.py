from util import *
from euclidean_domain import *

# Compute the gcd of x and y as well as data needed
# to compute the Bezout pair
# We assume |x|>=|y|
def gcdaux1(x,y,l):
    # Degenerate cases: (x,0)=(0,x)=x
    if x.norm()==0: return y, l
    elif y.norm()==0: return x, l
    q,r = x.div(y)
    # y|x
    if r.norm()==0: return y, l
    # note we have |r|<|y|<=|x|
    else: return gcdaux1(y,r,l+[q])

# Compute the gcd of x and y as well as the Bezout pair
# We assume |x|>=|y|
def gcdaux2(x,y):
    assert(type(x)==type(y))
    assert(x.norm()>=y.norm())
    cls = type(x)
    d,l = gcdaux1(x,y,[])
    # degenerate cases: either y|x or y=0
    if not l: return (x,cls.one,cls.zero) if y.norm()==0 else (y,cls.zero,cls.one)
    # the Bezout pair is computed via a recurrence
    q1 = l[0]
    prevtwo = (cls.zero, cls.one, cls.one, -q1)
    for q in l[1:]:
        a0,b0,a1,b1 = prevtwo
        a2,b2 = a0-q*a1, b0-q*b1
        prevtwo = (a1,b1,a2,b2)
    _,_,a,b = prevtwo
    return d,a,b

# Short for 'gcd and bezout'
def gab(x,y):
    if x.norm()>=y.norm(): return gcdaux2(x,y)
    else:
        d,a,b = gcdaux2(y,x)
        return d,b,a

# Computes gcd of a list as well as its Bezout numbers
def gablist(l):
    ais = []
    d = l[0]
    for idx,x in enumerate(l[1:]):
        d,a,b = gab(d,x)
        if idx==0: ais = [a,b]
        else: ais = smul(a,ais)+[b]
    return d, ais

def solvezerotwo(x,y):
    cls = type(x)
    if x.norm()==0 and y.norm()!=0: return [[cls.one,cls.zero]]
    elif x.norm()!=0 and y.norm()==0: return [[cls.zero,cls.one]]
    elif x.norm()==0 and y.norm()==0: return [[cls.one,cls.zero],
                                            [cls.zero,cls.one]]
    d,_,_ = gab(x,y)
    return [[y/d,-x/d]]

# Given a list xs=[x1,...,xn], compute a matrix M
# encoding a basis for the space of solutions to
# the equation sum_i aixi = 0
def solvezero(xs):
    cls = type(xs[0])
    n = len(xs)
    if len(xs)==1:
        r = cls.one if xs[0].norm()==0 else cls.zero
        return [[r]]
    if len(xs)==2: return solvezerotwo(*xs)
    x,xs = xs[0], xs[1:]
    M = []
    d,l = gablist(xs)
    a,b = solvezerotwo(x,d)[0]
    M.append([a]+smul(b,l))
    return M + insertcol(solvezero(xs),0,cls.zero)

# Short for 'basis of submodule generated by'
# M is a 2D array whose elements are the generating tuples
def bosgb(M):
    cls = type(M[0][0])
    if all(j==cls.zero for l in M for j in l):
        return None
    if len(M[0])==1:
        l = [l[0] for l in M]
        d,_ = gablist(l)
        return [[d]]
    d, ais = gablist(col(M,0))
    c = col(M,0)
    d,l = gablist(c)
    l1 = lincombi(M,l)
    M_ = [lincombi(M,l) for l in solvezero(c)]
    M_ = [l[1:] for l in M_]
    M__ = bosgb(M_)
    return [l1] if M__==None else [l1]+insertcol(M__,0,cls.zero)

M = [[1,0,-1],[2,-3,1],[0,3,1],[3,1,5]]
M = map2d(Int,M)
print(bosgb(M))

M = [[(-1,2),(0,1),(3,0,1)],
     [(0,1),(0,1),(0,0,1)],
     [(1,1),(0,2),(-3,0,2)]]
M = map2d(QPoly,M)
print(bosgb(M))

l1 = list(map(Int,[1,2,3]))
l2 = list(map(Int,[1,4,9]))
print(solvezero(l1),solvezero(l2))