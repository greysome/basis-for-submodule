'''
This file contains the meat of this whole project: routines for
working with finitely generated modules over a PID.
'''
from matrix import *
from euclidean_domain import *

'''
Let L = [x1,...,xn]. solve(L) returns a matrix whose rows
generate the solutions to the equation
a1x1 + ... + anxn = 0.
'''
def solve(L: list[EuclideanDomain]) -> MatrixType:
    # Degenerate cases:
    # 1. Empty solution set
    if len(L) == 0: return M()
    typ = type(L[0])
    # 2. Solving ax=0
    if len(L) == 1: return M(typ.one) if L[0]==typ.zero else M(typ.zero)

    x1, *xs = L
    d, bs = egcdl(xs)
    l = lcm(x1,d)
    # Base case
    if len(L) == 2:
        match (L[0], L[1]):
            # First 3 cases are degenerate.
            # 1. Solutions to a0+b0=0 are generated by (1,0), (0,1)
            case (typ.zero, typ.zero): return M(typ.one, typ.zero, typ.zero, typ.one)
            # 2. Solutions to a0+by=0 (y != 0) are generated by (1,0)
            case (typ.zero, other): return M(typ.one, typ.zero, eor)
            # 3. Solutions to ax+b0=0 (x != 0) are generated by (0,1)
            case (other, typ.zero): return M(typ.zero, typ.one, eor)
            # The non-degenerate case:
            # 4. Solutions to a1x1+a2x2=0 are generated by (l/x1,-l/x2)
            case other: return M(l/x1, -l/xs[0], eor)

    # Inductive case
    bs = [-l/d*b for b in bs]
    if x1 == typ.zero:
        return row(typ.one, *bs) | (col() | solve(L[1:]))
    else:
        return row(l/x1, *bs) | (col() | solve(L[1:]))

'''
Return the linear combination of the rows of A by the elements of L.
'''
def lincombi(A: MatrixType, L: list[EuclideanDomain]) -> MatrixType:
    return sum([x * A[idx] for idx, x in enumerate(L)],
               None)

'''
Short for 'basis of submodule generated by'.
Return a matrix representing the basis for the submodule
generated by the rows of A.
'''
def bosgb(A: MatrixType) -> MatrixType:
    if A == Matrix(): return Matrix()

    # Obtain a generator d for the ideal of first components
    d, cs = egcdl(A[:,0].lst)
    # The first basis element y1 will have first component d,
    # obtained as a linear combination of the rows of M.
    # All other basis elements will have first component 0.
    y1 = lincombi(A, cs)

    # solve(cs) is a generating set for the linear combinations
    # that yield elements with first component 0.
    # B is a matrix whose rows generate the elements with first
    # component 0.
    B = None
    for row in solve(cs).data:
        B &= lincombi(A, row)

    # If B generates the zero submodule, then we are done.
    if B == None or all(x == B.typ.zero for x in flatten(B.data)):
        return y1

    # Remove all first components from B.
    B = B[:,1:]
    # Recurse and combine results with y1.
    B_ = bosgb(B)
    return y1 if B_ == Matrix() else y1 & (col() | B_)

def min_nonzero_norm(A: MatrixType) -> tuple[int,int,int]:
    _min = None
    minidx = (0,0)
    for i in range(A.m):
        for j in range(A.n):
            n = A[i,j].norm
            if n != 0 and (_min == None or n < _min):
                _min, minidx = n, (i,j)
    return _min, *minidx

def clear_col_row(A: MatrixType) -> MatrixType:
    while True:
        restart = False
        n, a, b = min_nonzero_norm(A)

        # all entries are 0
        if n == None: return A

        for i in range(A.m):
            if A[i,b] == A.typ.zero or i==a: continue
            q, r = A[i,b].div(A[a,b])
            A[i] -= q * A[a]
            if r != A.typ.zero:
                restart = True
                break
        if restart: continue

        for j in range(A.m):
            if A[a,j] == A.typ.zero or j==b: continue
            q, r = A[a,j].div(A[a,b])
            A[:,j] -= q * A[:,b]
            if r != A.typ.zero:
                restart = True
                break
        if restart: continue

        # row and column around A[a,b] cleared, now shift it
        # to the top-left corner
        A[:,0], A[:,b] = A[:,b], A[:,0]
        A[0], A[a] = A[a], A[0]
        return

def smith(A: MatrixType) -> MatrixType:
    if A == Matrix(): return Matrix()
    while True:
        clear_col_row(A)
        # does the first diagonal entry divide all other entries?
        if (x := A[1:,1:].find(lambda x: x % A.data[0][0] != A.typ.zero)) == None:
            break
        a, b = x[0]+1, x[1]+1
        A[0] += A[a]
    A_ = smith(A[1:,1:])
    A.data[0][0] = A.data[0][0].normalise()
    if A_ == Matrix(): return A[0][0]
    else: return row(A.data[0][0], *[A.typ.zero for _ in range(A.m-1)]) | \
        (col() | A_)