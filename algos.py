'''
This file contains the meat of this whole project: routines for
working with finitely generated modules over a PID.
'''
from matrix import *
from euclidean_domain import *

'''
Let L = [x1,...,xn]. solvezero(L) returns a matrix whose rows
generate the solutions to the equation
a1x1 + ... + anxn = 0.
'''
def solvezero(L: list[EuclideanDomain]) -> MatrixType:
    # Degenerate cases:
    # 1. Empty solution set
    if len(L) == 0: return M()
    typ = type(L[0])
    # 2. Solving ax=0
    if len(L) == 1: return M(typ.one) if L[0]==typ.zero else M(typ.zero)

    x1, *xs = L
    d, bs = egcdl(xs)
    l = lcm(x1,d)
    # Base case: solutions to a1x1+a2x2=0 are generated by (l/x1,-l/x2)
    if len(L) == 2:
        match (L[0], L[1]):
            # First 3 cases are degenerate.
            # 1. Solutions to a0+b0=0 are generated by (1,0), (0,1)
            # 2. Solutions to a0+by=0 (y != 0) are generated by (1,0)
            # 3. Solutions to ax+b0=0 (x != 0) are generated by (0,1)
            case (typ.zero, typ.zero): return M(typ.one, typ.zero, typ.zero, typ.one)
            case (typ.zero, other): return M(typ.one, typ.zero, eor)
            case (other, typ.zero): return M(typ.zero, typ.one, eor)
            case other: return M(l/x1, -l/xs[0], eor)

    # Inductive case
    bs = [-l/d*b for b in bs]
    if x1 == typ.zero:
        return row(typ.one, *bs) | (col() | solvezero(L[1:]))
    else:
        return row(l/x1, *bs) | (col() | solvezero(L[1:]))

'''
Return the linear combination of the rows of A by the elements of L.
'''
def lincombi(A: MatrixType, L: list[EuclideanDomain]) -> MatrixType:
    return sum([x * A[idx] for idx, x in enumerate(L)],
               None)

'''
Short for 'basis of submodule generated by'.
Return a matrix representing the basis for the submodule
generated by the rows of A.
'''
def bosgb(A: MatrixType) -> MatrixType:
    if A == Matrix(): return Matrix()

    # Obtain a generator d for the ideal of first components
    d, cs = egcdl(A[:,0].lst)
    # The first basis element y1 will have first component d,
    # obtained as a linear combination of the rows of M.
    # All other basis elements will have first component 0.
    y1 = lincombi(A, cs)

    # solvezero(cs) is a generating set for the linear combinations
    # that yield elements with first component 0.
    # B is a matrix whose rows generate the elements with first
    # component 0.
    B = None
    for row in solvezero(cs).data:
        B &= lincombi(A, row)
    if B == None: return y1

    # Remove all first components from B.
    B = B[:,1:]
    # Recurse and combine results with y1.
    B_ = bosgb(B)
    return y1 if B_ == Matrix() else y1 & (col() | B_)

print(bosgb(mapM(Int,1,0,-1,eor,2,-3,1,0,3,1,3,1,5)))
print(bosgb(M(2*X-1,X,X**2+3,X,X,X**2,X+1,2*X,2*X**2-3)))