'''
This file contains the meat of this whole project: routines for
working with finitely generated modules over a PID.
'''
from matrix import *
from euclidean_domain import *

'''
Let L = [x1,...,xn]. solve(L) returns a matrix whose rows
generate the solutions to the equation
a1x1 + ... + anxn = 0.
'''
def solve(L: list[EuclideanDomain]) -> MatrixType:
    # Degenerate cases:
    # 1. Empty solution set
    if len(L) == 0: return Matrix()
    typ = type(L[0])
    # 2. Solving ax=0
    if len(L) == 1: return M(typ.one) if L[0]==typ.zero else M(typ.zero)

    x1, *xs = L
    d, bs = egcdl(xs)
    l = lcm(x1,d)
    # Base case
    if len(L) == 2:
        match (L[0], L[1]):
            # First 3 cases are degenerate.
            # 1. Solutions to a0+b0=0 are generated by (1,0), (0,1)
            case (typ.zero, typ.zero): return M(typ.one, typ.zero, typ.zero, typ.one)
            # 2. Solutions to a0+by=0 (y != 0) are generated by (1,0)
            case (typ.zero, other): return M(typ.one, typ.zero, eor)
            # 3. Solutions to ax+b0=0 (x != 0) are generated by (0,1)
            case (other, typ.zero): return M(typ.zero, typ.one, eor)
            # The non-degenerate case:
            # 4. Solutions to a1x1+a2x2=0 are generated by (l/x1,-l/x2)
            case other: return M(l/x1, -l/xs[0], eor)

    # Inductive case
    bs = [-l/d*b for b in bs]
    if x1 == typ.zero:
        return row(typ.one, *bs) | (col() | solve(L[1:]))
    else:
        return row(l/x1, *bs) | (col() | solve(L[1:]))

'''
Return the linear combination of the rows of A by the elements of L.
'''
def lincombi(A: MatrixType, L: list[EuclideanDomain]) -> MatrixType:
    return sum([x * A[idx] for idx, x in enumerate(L)],
               None)

'''
Short for 'basis of submodule generated by'.
Return a matrix representing the basis for the submodule
generated by the rows of A.
'''
def bosgb(A: MatrixType) -> MatrixType:
    if A == Matrix(): return Matrix()

    # Obtain a generator d for the ideal of first components
    d, cs = egcdl(A[:,0].lst)
    # The first basis element y1 will have first component d,
    # obtained as a linear combination of the rows of M.
    # All other basis elements will have first component 0.
    y1 = lincombi(A, cs)

    # solve(cs) is a generating set for the linear combinations
    # that yield elements with first component 0.
    # B is a matrix whose rows generate the elements with first
    # component 0.
    B = None
    for row in solve(cs).data:
        B &= lincombi(A, row)

    # If B generates the zero submodule, then we are done.
    if B == None or all(x == B.typ.zero for x in flatten(B.data)):
        return y1

    # Remove all first components from B.
    B = B[:,1:]
    # Recurse and combine results with y1.
    B_ = bosgb(B)
    return y1 if B_ == Matrix() else y1 & (col() | B_)

def min_nonzero_norm(A: MatrixType) -> tuple[int,int,int]:
    _min = None
    minidx = (0,0)
    for i in range(A.m):
        for j in range(A.n):
            n = A[i,j].norm
            if n != 0 and (_min == None or n < _min):
                _min, minidx = n, (i,j)
    return _min, *minidx

def clear_col_row(A: MatrixType) -> tuple[MatrixType,MatrixType]:
    P = I(A.typ, A.m)
    Q = I(A.typ, A.n)
    while True:
        restart = False
        n, a, b = min_nonzero_norm(A)

        # all entries are 0
        if n == None: return P, Q

        for i in range(A.m):
            if A[i,b] == A.typ.zero or i==a: continue
            q, r = A[i,b].div(A[a,b])
            P = A.addrow(i, a, -q) * P
            if r != A.typ.zero:
                restart = True
                break
        if restart: continue

        for j in range(A.n):
            if A[a,j] == A.typ.zero or j==b: continue
            q, r = A[a,j].div(A[a,b])
            Q *= A.addcol(j, b, -q)
            if r != A.typ.zero:
                restart = True
                break
        if restart: continue

        # row and column around A[a,b] cleared, now shift it
        # to the top-left corner
        P = A.swaprow(0,a) * P
        Q *= A.swapcol(0,b)
        return P, Q

def _smith(A: MatrixType, P: MatrixType, Q: MatrixType) -> tuple[MatrixType,MatrixType,MatrixType]:
    A = deepcopy(A)  # don't modify the original copy
    if A == Matrix(): return Matrix(), None, None
    while True:
        P_, Q_ = clear_col_row(A)
        P = P_ * P
        Q *= Q_
        # does the first diagonal entry divide all other entries?
        if (x := A[1:,1:].find(lambda x: x % A[0,0] != A.typ.zero)) == None:
            break
        a, b = x[0]+1, x[1]+1

        P = A.addrow(0, a, A.typ.one) * P

    A[0,0] = A[0,0].normalise()
    A_, P_, Q_ = smith(A[1:,1:])
    if A_ == Matrix():
        return A, P, Q
    else:
        P_ = M(A.typ.one) ^ P_
        Q_ = M(A.typ.one) ^ Q_
        P = P_ * P
        Q *= Q_
        return M(A[0,0]) ^ A_, P, Q

'''
Compute the smith normal form B of A, as well as matrices P, Q such
that B = PAQ (up to units).
'''
def smith(A: MatrixType) -> tuple[MatrixType,MatrixType,MatrixType]:
    return _smith(A, I(A.typ, A.m), I(A.typ, A.n))

'''
Return a matrix whose rows form a basis of the solution space
{x | Ax = 0}.
'''
def solve2(A: MatrixType) -> MatrixType:
    # We reduce A to Smith normal form, whose solutions are easily
    # described.
    B, P, Q = smith(A)

    # Find the leftmost column j such that B[j,j] = 0, otherwise None.
    j = 0
    for j in range(B.n):
        try:
            if B[j,j] == B.typ.zero:
                break
        except IndexError:  # columns >= rows
            break
    else: j = None

    if j == None: return Matrix()  # the solution space is {0}
    # The solutions S to Bx = 0 are generated by the basis {e_j,
    # e_{j+1}, ..., e_n}.
    S = M()
    for j_ in range(j, B.n):
        S |= col(*[B.typ.zero for _ in range(j_)],
                 B.typ.one,
                 *[B.typ.zero for _ in range(B.n-j_-1)])
    # Pass them through Q to get the solutions y to BQ^{-1}y = 0, or
    # equivalently Ay = P^{-1}BQ^{-1}y = 0.
    # Take transpose so that the basis elements form rows.
    return (Q * S).transpose

def invariants(K: MatrixType) -> list[EuclideanDomain]:
    A, P, Q = smith(K)
    annihilators = [A[i,i] for i in range(min(A.m,A.n))]
    annihilators += [A.typ.zero for i in range(max(0, A.n-A.m))]
    return annihilators

def elementaries(K: MatrixType) -> tuple[int, list[tuple[EuclideanDomain,int]]]:
    L = invariants(K)
    rank = L.count(K.typ.zero)
    L = filter(lambda x: x not in (K.typ.zero, K.typ.one), L)
    L = list(map(lambda x: x.factors, L))
    all_factors = reduce(lambda l,x: l.union(set(x[1].keys())), L, set())
    prime_powers = []
    for p in all_factors:
        for unit, factors in L:
            if p in factors.keys():
                prime_powers.append((p, factors[p]))
    return rank, prime_powers

'''
Pretty print the direct sum decomposition for D^m/K in terms of invariant factors.
Here `K.typ = D` and `K.m = m`.
'''
def print_invariants(K: MatrixType) -> None:
    strs = []
    for d in invariants(K):
        if d == K.typ.zero:
            strs.append(K.typ.notation)
        elif d != K.typ.one:
            strs.append(f'{K.typ.notation}/({d})')
    print(' \u2295 '.join(strs))

'''
Pretty print the direct sum decomposition for D^m/K in terms of elementary factors.
Here `K.typ = D` and `K.m = m`.
'''
def print_elementaries(K: MatrixType) -> None:
    rank, L = elementaries(K)
    strs = []
    for p, power in L:
        if power == 1:
            strs.append(f'{K.typ.notation}/({p})')
        else:
            strs.append(f'{K.typ.notation}/({p})^{power}')
    strs += [K.typ.notation for _ in range(rank)]
    print(' \u2295 '.join(strs))

'''
Companion matrix for the polynomial P.
'''
def companion(P: Poly) -> MatrixType:
    P = P.normalise()
    deg = len(P.coeffs) - 1
    if deg == 0:
        return Matrix()
    elif deg == 1:
        return M(-P.coeffs[0])
    else:
        return (col() | I(float, deg-1)) | row(*(-P).coeffs[:-1])

'''
The rational canonical form. Currently only supports matrices over Q.
'''
def rcf(K: MatrixType) -> None:
    assert K.typ in (int,float,Int)

    # convert K to the matrix K-X*I over Poly
    data = K.data
    for i in range(K.m):
        for j in range(K.n):
            if i == j:
                data[i][j] -= X
            else:
                data[i][j] = data[i][j]*C

    K = Matrix(data)
    L = invariants(K)
    K_ = Matrix()
    for P in L:
        K_ ^= companion(P)
    return K_